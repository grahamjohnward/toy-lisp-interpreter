(defmacro do-test (expression expected-value)
  `(progn
     (setq test-count (+ 1 test-count))
     (let ((v ,expression))
     (if (equalp v ,expected-value)
; 	 (print "ok")
	 (cons 'a 'b)
	 (progn
	   (setq fail-count (+ 1 fail-count))
	   (print `(test failed ,',expression expected ,,expected-value was ,v)))))))

(defmacro do-tests (&body tests)
  `(let ((test-count 0)
	 (fail-count 0))
     (progn
       (progn
	 ,@tests)
       (if (= fail-count 0)
	   (princ "All tests successful\n")
	   (progn
	     (princ fail-count)
	     (princ "/")
	     (princ test-count)
	     (princ " test(s) failed\n")))
       (exit fail-count))))

(defun test-function (a b)
  (cons 'hello (+ a b)))

(do-tests
  (do-test (type-of 14) 'integer)
  (do-test (type-of 'foo) 'symbol)
  (do-test (type-of (cons 'a nil)) 'cons)
  (do-test (type-of "foo") 'string)
  (do-test (type-of #(1 2 3)) 'vector)
  (do-test (> 3 2 1) t)
  (do-test (> 3 1 2) nil)
  (do-test (> -1 -2 -3) t)
  (do-test (< 1 2 3) t)
  (do-test (- 10) -10)
  (do-test (- 10 8) 2)
  (do-test (- 10 6 3) 1)
  (do-test (equalp 3 3) t)
  (do-test (equalp 3 -1) nil)
  (do-test (equalp 'foo 'foo) t)
  (do-test (equalp 'foo 'bar) nil)
  (do-test (equalp #(1 2 3) #(1 2 3)) t)
  (do-test (equalp #(1 2 3) #(1 2 4)) nil)
  (do-test (equalp #(1 2 3) #(1 2 3 4)) nil)
  (do-test (funcall (function (lambda (x) (prog (y) (setq y 12) bof (setq x 36) boo (return (cons x y))))) 14) '(36 . 12))
  (do-test (funcall (lambda (x) (+ x 1)) 14) 15)
  (do-test (condition-case e (test-function 1) (bad-args 'ok)) 'ok)
  (do-test (condition-case e (test-function 1 2 3) (bad-args 'ok)) 'ok)
  (do-test (let (x y) (let ((z (prog1 (+ 3 3) (setq x 14) (setq y 12)))) (list x y z))) '(14 12 6)))
